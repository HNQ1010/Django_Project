<!DOCTYPE html>
<html lang="en">
<head>
    {% load static %}
    <meta charset="UTF-8">
    <title>SQL Server Stored Procedures</title>
</head>
<body>
<h1 style="color:red ; text-align:center"><b>STORE PROCEDURE</b></h1>
<ul>
    <li>SQL Server stored procedures are used to group one or more Transact-SQL statements into logical units. </li>
    <li>The stored procedure is stored as a named object in the SQL Server Database Server.</li>
    <li>When you call a stored procedure for the first time, SQL Server creates an execution plan and stores it in the cache.</li>
    <li> In the subsequent executions of the stored procedure, SQL Server reuses the plan to execute the stored procedure very fast with reliable performance.</li>
</ul>

<h1 style="color:#3A578F">Section 1. Getting started with SQL Server Stored Procedures</h1>
    <ul>
        <h3 style="color:red">1) A basic guide to stored procedures</h3>
            <ul>
                <h4 style="color:blue"><b>*Creating a simple stored procedure</b></h4>
                <textarea rows= "13" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    CREATE PROCEDURE uspProductList
                    (Or CREATE PROC uspProductList)
                        AS
                        BEGIN
                            SELECT
                                product_name,
                                list_price
                            FROM
                                production.products
                            ORDER BY
                                product_name;
                        END;
                </textarea>
                <ul>
                    <li><b>The uspProductList :</b>is the name of the stored procedure.</li>
                    <li><b>The AS :</b>keyword separates the heading and the body of the stored procedure.</li>
                    <li>If the stored procedure has one statement, the BEGIN and END keywords surrounding the statement are optional.</li>
                </ul>
                <li style="color:blue">Note that in addition to the CREATE PROCEDURE keywords, you can use the CREATE PROC keywords</li>
                <li>You can find the stored procedure in the Object Explorer, under Programmability > Stored Procedures </li>
                <h4 style="color:blue"><b>*Executing a stored procedure</b></h4>
                    <textarea rows= "4" cols="50" style="color:#1F0221; font-family:Times New Roman">
                            EXECUTE sp_name; Or EXEC sp_name;
                        E.g:
                            EXEC uspProductList;
                    </textarea>
                <h4 style="color:blue"><b>*Modifying a stored procedure</b></h4>
                <li>To modify an existing stored procedure, you use the ALTER PROCEDURE statement.</li>
                <li>Or use MODIFY option by right click in PROCEDURE</li>
                    <textarea rows= "12" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        ALTER PROCEDURE uspProductList
                            AS
                            BEGIN
                                SELECT
                                    product_name,
                                    list_price
                                FROM
                                    production.products
                                ORDER BY
                                    list_price
                            END;
                    </textarea>
                <h4 style="color:blue"><b>*Deleting a stored procedure</b></h4>
                <li>To modify an existing stored procedure, you use the ALTER PROCEDURE statement.</li>
                <li>Or use MODIFY option by right click in PROCEDURE</li>
                    <textarea rows= "4" cols="50" style="color:#1F0221; font-family:Times New Roman">
                            DROP PROCEDURE sp_name;
                        Or
                            DROP PROC sp_name;
                    </textarea>
            </ul>
        <h3 style="color:red">2) Stored Procedure Parameters</h3>
            <ul>
                <h4 style="color:blue"><b>*Creating a stored procedure with parameter(s)</b></h4>
                <li>This time we can add a parameter to the stored procedure</li>
                <li>The result of the stored procedure will change based on the values of the parameters.</li>
                <textarea rows= "20" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    ALTER PROCEDURE uspFindProducts(
                            @min_list_price AS DECIMAL,
                            @max_list_price AS DECIMAL,
                            ,@name AS VARCHAR(max)
                        )
                        AS
                        BEGIN
                            SELECT
                                product_name,
                                list_price
                            FROM
                                production.products
                            WHERE
                                list_price >= @min_list_price AND
                                list_price <= @max_list_price AND
                                product_name LIKE "%' + @name + '%'
                            ORDER BY
                                list_price;
                        END;
                </textarea>
                <ul>
                    <li><b>@min_list_price :</b>is the parameter name.<span style="color:blue"> Every parameter must start with the @ sign.</span><br>
                    <li><b>AS DECIMAL:</b> specify the data type of the @min_list_price parameter. The parameter must be surrounded by the opening and closing brackets.</li>
                    <li>We used @min_list_price parameter in the WHERE clause of the SELECT statement to filter only the products whose list prices are >= the @min_list_price.</li>
                </ul>

                <h4 style="color:blue"><b>*Executing a stored procedure with parameter(s)</b></h4>
                    <textarea rows= "2" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        EXEC uspFindProducts 100 ,200, 'Trek';
                    </textarea>
                <li><span style="color:blue">In case stored procedures have multiple parameters, it is better and more clear to execute the stored procedures using named parameters.</span></li>
                    <textarea rows= "5" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        EXEC uspFindProducts
                            @min_list_price = 900,
                            @max_list_price = 1000,
                            @name = 'Trek';
                    </textarea>
                <h4 style="color:blue"><b>*Creating optional parameters</b></h4>
                <li>When you execute the uspFindProducts stored procedure, you must pass all three arguments corresponding to the three parameters.</li>
                <li><span style="color:blue"> SQL Server allows you to specify default values for parameters so that when you call stored procedures, you can skip the parameters with default values.</span></li>
                    <textarea rows= "20" cols="70" style="color:#1F0221; font-family:Times New Roman">
                        ALTER PROCEDURE uspFindProducts(
                                @min_list_price AS DECIMAL = 0
                                ,@max_list_price AS DECIMAL = 999999
                                ,@name AS VARCHAR(max)
                                )
                            AS
                            BEGIN
                                SELECT
                                    product_name,
                                    list_price
                                FROM
                                    production.products
                                WHERE
                                    list_price >= @min_list_price AND
                                    list_price <= @max_list_price AND
                                    product_name LIKE '%' + @name + '%'
                                ORDER BY
                                    list_price;
                            END;
                    </textarea>
                <li>Once the stored procedure is compiled, you can execute it without passing the arguments to @min_list_price and @max_list_price.</li>
                    <textarea rows= "3" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        EXEC uspFindProducts
                            @name = 'Trek';
                    </textarea>
                <li>In this case, @min_list_price = 0 and @max_list_price = 999,999 parameter when executing the query.</li>
                <li>The @min_list_price and @max_list_price parameters are called optional parameters.</li>
                <li>However, you can also pass the arguments to the optional parameters.</li>
                    <textarea rows= "4" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        EXECUTE uspFindProducts
                            @min_list_price = 6000,
                            @name = 'Trek';
                    </textarea>
                <h4 style="color:blue"><b>*Using NULL as the default value</b></h4>
                <li>The default value of @max_list_price is not robust when you may have products with the list prices that are greater than in the future.</li>
                <li>A typical technique to avoid this is to use NULL as the default value for the parameters.</li>
                    <textarea rows= "20" cols="100" style="color:#1F0221; font-family:Times New Roman">
                        ALTER PROCEDURE uspFindProducts(
                                @min_list_price AS DECIMAL = 0
                                ,@max_list_price AS DECIMAL = NULL
                                ,@name AS VARCHAR(max)
                                )
                            AS
                            BEGIN
                                SELECT
                                    product_name,
                                    list_price
                                FROM
                                    production.products
                                WHERE
                                    list_price >= @min_list_price AND
                                    (@max_list_price IS NULL OR list_price <= @max_list_price) AND
                                    product_name LIKE '%' + @name + '%'
                                ORDER BY
                                    list_price;
                            END;
                    </textarea>
                <li>In the WHERE clause, we changed the condition to handle NULL value for the @max_list_price parameter</li>
            </ul>
        <h3 style="color:red">3) Variables</h3>
            <ul>
                <li>A variable is an object that holds a single value of a specific type e.g., integer, date, or varying character string.</li>
                <li>We typically use variables in the following cases:</li>
                    <ul>
                        <li>As a loop counter to count the number of times a loop is performed.</li>
                        <li>To hold a value to be tested by a control-of-flow statement such as WHILE.</li>
                        <li>To store the value returned by a stored procedure or a function</li>
                    </ul>
                <h4 style="color:blue"><b>*Declaring a variable</b></h4>
                <li>To declare a variable, you use the DECLARE statement.</li>
                <li>A typical technique to avoid this is to use NULL as the default value for the parameters.</li>
                <li><span style="color:blue">The variable name must start with the @ sign.</span></li>
                <li><span style="color:blue">By default, when a variable is declared, its value is set to NULL.</span></li>
                    <textarea rows= "4" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        DECLARE @model_year SMALLINT,
                            @product_name VARCHAR(MAX);
                    </textarea>
                <h4 style="color:blue"><b>*Assigning a value to a variable</b></h4>
                <li>To assign a value to a variable, you use the SET statement. </li>
                    <textarea rows= "2" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        SET @model_year = 2018;
                    </textarea>
                <h4 style="color:blue"><b>*Using variables in a query</b></h4>
                    <textarea rows= "15" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        DECLARE @model_year SMALLINT;

                            SET @model_year = 2018;

                            SELECT
                                product_name,
                                model_year,
                                list_price
                            FROM
                                production.products
                            WHERE
                                model_year = @model_year
                            ORDER BY
                                product_name;
                    </textarea>
                <h4 style="color:blue"><b>*Storing query result in a variable</b></h4>
                    <textarea rows= "9" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        DECLARE @product_count INT;

                            SET @product_count = (
                                    SELECT
                                        COUNT(*)
                                    FROM
                                        production.products
                                );
                    </textarea>
                <li>output the content of the @product_count variable:</li>
                    <textarea rows= "6" cols="100" style="color:#1F0221; font-family:Times New Roman">
                            SELECT @product_count;
                        Or
                            PRINT @product_count;
                        Or
                            PRINT 'The number of products is ' + CAST(@product_count AS VARCHAR(MAX));
                    </textarea>
                <h4 style="color:blue"><b>*Selecting a record into variables</b></h4>
                    <textarea rows= "9" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        DECLARE @product_count INT;

                            SET @product_count = (
                                    SELECT
                                        COUNT(*)
                                    FROM
                                        production.products
                                );
                    </textarea>
                <h4 style="color:blue"><b>*NOCOUNT ON| OFF and GRANT</b></h4>
                    <textarea rows= "26" cols="100" style="color:#1F0221; font-family:Times New Roman">
                        CREATE PROCEDURE dbo.FAQ_InsertBook
                            @title VARCHAR(255),
                            @pubdate DATETIME,
                            @synopsis VARCHAR(4000),
                            @salesCount INT
                        AS
                            BEGIN
                                SET NOCOUNT ON
                                DECLARE @newBookID INT
                                INSERT BOOKS (
                                            title,
                                            pubdate,
                                            synopsis,
                                            salesCount )
                                VALUES (
                                            @title,
                                            @pubdate,
                                            @synopsis,
                                            @salesCount )
                                SELECT @newBookID = @@IDENTITY
                                SELECT newBookID = @newBookID
                            END
                        GO
                        GRANT EXEC ON dbo.FAQ_InsertBook to myUsername
                        GO
                    </textarea>
                <li><b>SET NOCOUNT OFF :</b> Just get newBookID with the values return from @newBookID (The count is returned)</li>
                <li><b>SET NOCOUNT ON (Omit it) :</b>SQL Server ignore message with contend "x row(s) affected" maybe make SQL don't understand the code, cause of error message. (The count is not returned)</li>
                <li><b>GRANT EXEC ON</b>: Grant permission to username in database.</li>

                <h4 style="color:blue"><b>*Selecting a record into variables</b></h4>
                <textarea rows= "12" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        DECLARE
                            @product_name VARCHAR(MAX),
                            @list_price DECIMAL(10,2);
                </textarea>
                <textarea rows= "12" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        SELECT
                            @product_name = product_name,
                            @list_price = list_price
                        FROM
                            production.products
                        WHERE
                            product_id = 100;
                </textarea>
                <textarea rows= "12" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        SELECT
                            @product_name AS product_name,
                            @list_price AS list_price;
                </textarea>
                <ul>
                    <li>First, declare variables that hold the product name and list price:</li>
                    <li>Second, assign the column names to the corresponding variables:</li>
                    <li>Third, output the content of the variables:</li>
                </ul>
                <h4 style="color:blue"><b>*Accumulating values into a variable</b></h4>
                <textarea rows= "20" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    CREATE  PROC    uspGetProductList(
                                    @model_year SMALLINT )
                        AS
                        BEGIN
                            DECLARE @product_list VARCHAR(MAX);

                            SET @product_list = '';

                            SELECT
                                @product_list = @product_list + product_name + CHAR(10)
                            FROM
                                production.products
                            WHERE
                                model_year = @model_year
                            ORDER BY
                                product_name;

                            PRINT @product_list;
                        END;
                </textarea>
                <ul>
                    <li>First, we declared a variable named @product_list with varying character string type and set its value to blank.</li>
                    <li>Second, we selected the product name list from the products table based on the input @model_year. In the select list,<br>
                        we accumulated the product names to the @product_list variable. Note that the CHAR(10) returns the line feed character.</li>
                    <li>Third, we used the PRINT statement to print out the product list.</li>
                <h4 style="color:blue"><b>* Plus(+) Char() with SPECIAL CASE</b></h4>
                    <ul>
                        <li><b>CHAR(9)</b>  : Tab</li>
                        <li><b>CHAR(10)</b> : Moves the cursor down to the next line without returning to the beginning of the line.</li>
                        <li><b>CHAR(13)</b> : Moves the cursor to the beginning of the line without advancing to the next line.</li>
                    </ul>
                </ul>
            </ul>
        <h3 style="color:red">4) Output Parameters</h3>
            <ul>
                <h4 style="color:blue"><b>*Creating output parameters</b></h4>
                <textarea rows= "2" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    parameter_name data_type OUTPUT
                </textarea>
                <li>A stored procedure can have many output parameters and can be in any valid data type e.g., integer, date, and varying character.</li>
                <textarea rows= "16" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    CREATE PROCEDURE uspFindProductByModel (
                        @model_year SMALLINT,
                        @product_count INT OUTPUT
                        ) AS
                    BEGIN
                        SELECT
                            product_name,
                            list_price
                        FROM
                            production.products
                        WHERE
                            model_year = @model_year;

                        SELECT @product_count = @@ROWCOUNT;
                    END;
                </textarea>
                <ul>
                    <li>First, we created an output parameter named @product_count to store the number of products found.</li>
                    <li>Second, after the SELECT statement, we assigned the number of rows returned by the query(@@ROWCOUNT) to the @product_count parameter</li>
                    <li><span style="color:blue">Note that the @@ROWCOUNT is a system variable.</span></li>
                        <ul>
                            <li><b>@@ERROR</b> : Returns the error number for the last Transact-SQL statement executed.</li>
                            <li><b>@@IDENTITY</b> : Returns the last-inserted identity value.</li>
                            <li><b>@@PACK_RECEIVED</b> : Returns the number of input packets read from the network by SQL Server since it was last started.</li>
                            <li><b>@@ROWCOUNT</b> : Returns the number of rows affected by the last statement. If the number of rows is more than 2 billion, use ROWCOUNT_BIG.</li>
                            <li><b>@@TRANCOUNT</b> : Returns the number of BEGIN TRANSACTION statements that have occurred on the current connection.</li>
                            <ul>
                                <li style="color:red">The COMMIT statement will decrement the transaction count by 1.</li>
                                <li>The ROLLBACK statement will clear the @@TRANCOUNT variable to 0 because all active transactions will be rolled back.</li>
                            </ul>
                        </ul>
                </ul>
                <h4 style="color:blue"><b>*Calling stored procedures with output parameters</b></h4>
                <textarea rows= "8" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    DECLARE @count INT;

                    EXEC uspFindProductByModel
                        @model_year = 2018,
                        @product_count = @count OUTPUT;

                    SELECT @count AS 'Number of products found';
                </textarea>
                <ul>
                    <li>First, declare variables to hold the values returned by the output parameters</li>
                    <li>Second, use these variables in the stored procedure call.</li>
                </ul>
                <li>You also can call the uspFindProductByModel stored procedure as follows:</li>
                <textarea rows= "2" cols="100" style="color:#1F0221; font-family:Times New Roman">
                        EXEC uspFindProductByModel 2018, @count OUTPUT;
                </textarea>
                <li style="color:red">Note that if you forget the OUTPUT keyword after the @count variable, the @count variable will be NULL.</li>
            </ul>
    </ul>
<h1 style="color:#3A578F">Section 2. Control-of-flow statements</h1>
    <ul>
        <h3 style="color:red">1) BEGIN ... END</h3>
            <ul>
                <h4 style="color:blue"><b>*Overview of the BEGIN...END statement</b></h4>
                    <ul>
                        <li>Create a statement block that consists of multiple Transact-SQL statements that execute together.</li>
                        <li>We often use the BEGIN...END at the start and end of a stored procedure and function. But it is not strictly necessary.</li>
                        <li>The BEGIN...END statement is used to define a statement block (paragraphs).</li>
                        <li>A statement block consists of a set of SQL statements that execute together.</li>
                        <li style="color:blue">A statement block is also known as a batch.</li>
                        <textarea rows= "13" cols="50" style="color:#1F0221; font-family:Times New Roman">
                            BEGIN
                                { sql_statement | statement_block}
                            END
                        </textarea>
                        <textarea rows= "13" cols="100" style="color:#1F0221; font-family:Times New Roman">
                            BEGIN
                                SELECT
                                    product_id,
                                    product_name
                                FROM
                                    production.products
                                WHERE
                                    list_price > 100000;

                                IF @@ROWCOUNT = 0
                                    PRINT 'No product with price greater than 100000 found';
                            END
                        </textarea>

                    </ul>
                <h4 style="color:blue"><b>*Nesting BEGIN... END</b></h4>
                    <ul>
                        <li>You can place a BEGIN...END statement within another BEGIN... END statement.</li>
                        <li>We often use the BEGIN...END at the start and end of a stored procedure and function. But it is not strictly necessary.</li>
                        <li>The BEGIN...END statement is used to define a statement block (paragraphs).</li>
                        <li>A statement block consists of a set of SQL statements that execute together.</li>
                        <li style="color:blue">A statement block is also known as a batch.</li>
                        <textarea rows= "20" cols="100" style="color:#1F0221; font-family:Times New Roman">
                            BEGIN
                                    DECLARE @name VARCHAR(MAX);

                                    SELECT TOP 1
                                        @name = product_name
                                    FROM
                                        production.products
                                    ORDER BY
                                        list_price DESC;

                                IF @@ROWCOUNT <> 0
                                    BEGIN
                                        PRINT 'The most expensive product is ' + @name
                                    END
                                ELSE
                                    BEGIN
                                        PRINT 'No product found';
                                    END;
                            END
                        </textarea>

                    </ul>
            </ul>
        <h3 style="color:red">2) IF ELSE</h3>
            <ul>
                <li>The IF...ELSE statement is a control-flow statement that allows you to execute or skip a statement block based on a specified condition.</li>
                <h4 style="color:blue"><b>*Nesting BEGIN... END</b></h4>
                    <ul>
                        <textarea rows= "5" cols="50" style="color:#1F0221; font-family:Times New Roman">
                            IF boolean_expression
                                BEGIN
                                    { statement_block }
                                END
                        </textarea>
                        <li>If the Boolean_expression evaluates to TRUE then the statement_block in the BEGIN...END block is executed.<br>
                        Otherwise, the statement_block is skipped and the control of the program is passed to the statement after the END keyword.</li>
                        <textarea rows= "19" cols="100" style="color:#1F0221; font-family:Times New Roman">
                            BEGIN
                                    DECLARE @sales INT;

                                    SELECT
                                        @sales = SUM(list_price * quantity)
                                    FROM
                                        sales.order_items i
                                        INNER JOIN sales.orders o ON o.order_id = i.order_id
                                    WHERE
                                        YEAR(order_date) = 2018;

                                    SELECT @sales;

                                IF @sales > 1000000
                                    BEGIN
                                        PRINT 'Great! The sales amount in 2018 is greater than 1,000,000';
                                    END
                            END
                        </textarea>
                    </ul>
                <h4 style="color:blue"><b>*The IF ELSE statement</b></h4>
                    <ul>
                        <li>When the condition in the IF clause evaluates to FALSE and you want to execute another statement block, you can use the ELSE clause.</li>
                        <textarea rows= "9" cols="100" style="color:#1F0221; font-family:Times New Roman">
                            IF Boolean_expression
                                BEGIN
                                    -- Statement block executes when the Boolean expression is TRUE
                                END
                            ELSE
                                BEGIN
                                    -- Statement block executes when the Boolean expression is FALSE
                                END
                        </textarea><br>
                        <textarea rows= "23" cols="100" style="color:#1F0221; font-family:Times New Roman">
                            BEGIN
                                    DECLARE @sales INT;

                                    SELECT
                                        @sales = SUM(list_price * quantity)
                                    FROM
                                        sales.order_items i
                                        INNER JOIN sales.orders o ON o.order_id = i.order_id
                                    WHERE
                                        YEAR(order_date) = 2017;

                                    SELECT @sales;

                                IF @sales > 10000000
                                    BEGIN
                                        PRINT 'Great! The sales amount in 2018 is greater than 10,000,000';
                                    END
                                ELSE
                                    BEGIN
                                        PRINT 'Sales amount in 2017 did not reach 10,000,000';
                                    END
                            END
                        </textarea>
                    </ul>
                <h4 style="color:blue"><b>*Nested IF...ELSE</b></h4>
                    <ul>
                        <li>SQL Server allows you to nest an IF...ELSE statement within inside another IF...ELSE statement.</li>
                        <textarea rows= "13" cols="100" style="color:#1F0221; font-family:Times New Roman">
                            BEGIN
                                DECLARE @x INT = 10,
                                        @y INT = 20;

                                IF (@x > 0)
                                    BEGIN
                                        IF (@x < @y)
                                            PRINT 'x > 0 and x < y';
                                        ELSE
                                            PRINT 'x > 0 and x >= y';
                                    END
                            END
                        </textarea>
                    </ul>
            </ul>
        <h3 style="color:red">3) WHILE</h3>
            <ul>
                <li>The WHILE statement is a control-flow statement that allows you to execute a statement block repeatedly as long as a specified condition is TRUE.</li>
                <textarea rows= "8" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    WHILE Boolean_expression
                        { sql_statement | statement_block}
                </textarea>
                <textarea rows= "8" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    DECLARE @counter INT = 1;

                        WHILE @counter <= 5
                            BEGIN
                                PRINT @counter;
                                SET @counter = @counter + 1;
                            END
                </textarea>
            </ul>
        <h3 style="color:red">4) BREAK</h3>
            <ul>
                <li>To exit the current iteration of a loop, you use the BREAK statement.</li>
                <li style="color:blue">Note that the BREAK statement can be used only inside the WHILE loop. <br>
                    The IF statement is often used with the BREAK statement but it is not required.</li>
                <textarea rows= "8" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    WHILE Boolean_expression
                        BEGIN
                            -- statements
                           IF condition
                                BREAK;
                            -- other statements
                        END
                </textarea>
                <textarea rows= "8" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    DECLARE @counter INT = 1;

                        WHILE @counter <= 5
                            BEGIN
                                PRINT @counter;
                                SET @counter = @counter + 1;
                            END
                </textarea>
            </ul>
        <h3 style="color:red">5) CONTINUE</h3>
            <ul>
                <li>The CONTINUE statement stops the current iteration of the loop and starts the new one.</li>
                <textarea rows= "10" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    WHILE Boolean_expression
                        BEGIN
                            -- code to be executed
                            IF condition
                                CONTINUE;
                            -- code will be skipped if the condition is met
                        END
                </textarea>
                <textarea rows= "10" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    DECLARE @counter INT = 0;

                        WHILE @counter < 5
                            BEGIN
                                SET @counter = @counter + 1;
                                IF @counter = 3
                                    CONTINUE;
                                PRINT @counter;
                            END
                </textarea>
                <ul>
                    <li>First, we declared a variable named @counter and set its value to zero.</li>
                    <li>Then, the WHILE loop started. Inside the WHILE loop, we increased the counter by one in each<br>
                        iteration. If the @counter was three, we skipped printing out the value using the CONTINUE statement.<br>
                        That’s why in the output, you do not see the number three is showing up.</li>
                </ul>

            </ul>
    </ul>
<h1 style="color:#3A578F">Section 3. Cursors</h1>
    <ul>
        <h3 style="color:red">1)What is a database cursor</h3>
            <ul>
                <li style="color:blue">A database cursor is an object that enables traversal over the rows of a result set. It allows you to process individual row returned by a query.</li>
                <h4 style="color:blue"><b>*SQL Server cursor life cycle</b></h4>
                <img src="{% static 'IMG\SQL-Server-Cursor.png'%}">
            </ul>
        <li>First, declare a cursor.</li>
            <textarea rows= "3" cols="50" style="color:#1F0221; font-family:Times New Roman">
                DECLARE cursor_name CURSOR
                    FOR select_statement;
            </textarea>
        <li>Next, open and populate the cursor by executing the SELECT statement:</li>
            <textarea rows= "2" cols="50" style="color:#1F0221; font-family:Times New Roman">
                OPEN cursor_name;
            </textarea>
        <li>First, declare a cursor.</li>
            <textarea rows= "2" cols="50" style="color:#1F0221; font-family:Times New Roman">
                FETCH NEXT FROM cursor INTO variable_list;
            </textarea>
        <li style="color:blue">SQL Server provides the @@FETCHSTATUS function that returns the status of the last cursor FETCH statement executed against the cursor;<br>
            If @@FETCHSTATUS returns 0, meaning the FETCH statement was successful.</li>
            <textarea rows= "5" cols="50" style="color:#1F0221; font-family:Times New Roman">
                WHILE @@FETCH_STATUS = 0
                    BEGIN
                        FETCH NEXT FROM cursor_name;
                    END;
            </textarea>
        <li>After that, close the cursor:</li>
            <textarea rows= "2" cols="50" style="color:#1F0221; font-family:Times New Roman">
                CLOSE cursor_name;
            </textarea>
        <li style="color:blue">Finally, deallocate the cursor:delete a cursor and releases all resources used by cursor.</li>
            <textarea rows= "2" cols="50" style="color:#1F0221; font-family:Times New Roman">
                DEALLOCATE cursor_name;
            </textarea>
        <br>
        <textarea rows= "29" cols="100" style="color:#1F0221; font-family:Times New Roman">
                DECLARE
                    @product_name VARCHAR(MAX),
                    @list_price   DECIMAL;

                DECLARE cursor_product CURSOR
                    FOR SELECT
                            product_name,
                            list_price
                        FROM
                            production.products;

                OPEN cursor_product;

                    FETCH NEXT FROM cursor_product INTO
                        @product_name,
                        @list_price;

                WHILE @@FETCH_STATUS = 0
                    BEGIN
                        PRINT @product_name + CAST(@list_price AS varchar);
                        FETCH NEXT FROM cursor_product INTO
                            @product_name,
                            @list_price;
                    END;

                CLOSE cursor_product;

                DEALLOCATE cursor_product;
            </textarea>
    </ul>
<h1 style="color:#3A578F">Section 4. Handling Exceptions</h1>
    <ul>
        <h3 style="color:red">1)TRY CATCH</h3>
            <ul>
                <li>The TRY CATCH construct allows you to gracefully handle exceptions in SQL Server. </li>
                <li style="color:blue">To use the TRY CATCH construct, you first place a group of Transact-SQL statements that could cause an exception in a BEGIN TRY...END TRY block</li>
                <textarea rows= "4" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    BEGIN TRY
                       -- statements that may cause exceptions
                    END TRY
                </textarea>
                <li>Then you use a BEGIN CATCH...END CATCH block immediately after the TRY block:</li>
                <textarea rows= "4" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    BEGIN CATCH
                       -- statements that handle exception
                    END CATCH
                </textarea>
                <h4 style="color:blue"><b>*The CATCH block functions</b></h4>
                    <ul>
                        <li><b>ERROR_LINE()</b> : returns the line number on which the exception occurred.</li>
                        <li><b>ERROR_MESSAGE()</b> : returns the complete text of the generated error message.</li>
                        <li><b>ERROR_PROCEDURE()</b> :  returns the name of the stored procedure or trigger where the error occurred.</li>
                        <li><b>ERROR_NUMBER()</b> : returns the number of the error that occurred.</li>
                        <li><b>ERROR_SEVERITY()</b> : returns the severity level of the error that occurred.</li>
                        <li><b>ERROR_STATE()</b> : returns the state number of the error that occurred.</li>
                    </ul>
                <li style="color:red">Note that you only use these functions in the CATCH block. If you use them outside of the CATCH block, all of these functions will return NULL.</li>
                <h4 style="color:blue"><b>*Nested TRY CATCH constructs</b></h4>
                <textarea rows= "13" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    BEGIN TRY
                        --- statements that may cause exceptions
                    END TRY
                    BEGIN CATCH
                        -- statements to handle exception
                        BEGIN TRY
                            --- nested TRY block
                        END TRY
                        BEGIN CATCH
                            --- nested CATCH block
                        END CATCH
                    END CATCH
                </textarea>
                <h4 style="color:blue"><b>*TRY CATCH examples</b></h4>
                <li>First, create a stored procedure named usp_divide that divides two numbers:</li>
                <textarea rows= "21" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    CREATE PROC usp_divide(
                            @a decimal,
                            @b decimal,
                            @c decimal output
                        ) AS
                        BEGIN
                            BEGIN TRY
                                SET @c = @a / @b;
                            END TRY
                            BEGIN CATCH
                                SELECT
                                    ERROR_NUMBER() AS ErrorNumber
                                    ,ERROR_SEVERITY() AS ErrorSeverity
                                    ,ERROR_STATE() AS ErrorState
                                    ,ERROR_PROCEDURE() AS ErrorProcedure
                                    ,ERROR_LINE() AS ErrorLine
                                    ,ERROR_MESSAGE() AS ErrorMessage;
                            END CATCH
                        END;
                        GO
                </textarea>
                <li>Second, call the usp_divide stored procedure to divide 10 by 2:</li>
                <textarea rows= "4" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    DECLARE @r decimal;
                    EXEC usp_divide 10, 2, @r output;
                    PRINT @r;
                </textarea>
                <li>Because no exception occurred in the TRY block, the stored procedure completed at the TRY block.</li>
                <li>If you set @b = 0, the control was passed to the statement inside the CATCH block which returned the error’s detailed information.</li>
                <h4 style="color:blue"><b>*SQL Serer TRY CATCH with transactions</b></h4>
                <li style="color:blue">Inside a CATCH block, you can test the state of transactions by using the XACT_STATE() function.</li>
                <ul>
                    <li><b>If the XACT_STATE() function returns -1</b> :  an uncommittable transaction is pending, you should issue a ROLLBACK TRANSACTION statement.</li>
                    <li><b>In case the XACT_STATE() function returns 1</b> : an transaction is pending. You can issue a COMMIT TRANSACTION statement in this case.</li>
                    <li><b>If the XACT_STATE() function return 0</b> : No transaction is pending, therefore, you don’t need to take any action.</li>
                </ul>
                <li>First, Create a new stored procedure named usp_report_error that will be used in a CATCH block to report the detailed information of an error.</li>
                <textarea rows= "11" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    CREATE PROC usp_report_error
                        AS
                            SELECT
                                ERROR_NUMBER() AS ErrorNumber
                                ,ERROR_SEVERITY() AS ErrorSeverity
                                ,ERROR_STATE() AS ErrorState
                                ,ERROR_LINE () AS ErrorLine
                                ,ERROR_PROCEDURE() AS ErrorProcedure
                                ,ERROR_MESSAGE() AS ErrorMessage;
                        GO
                </textarea>
                <li>Then, develop a new stored procedure that deletes a row from the sales.persons</li>
                <textarea rows= "35" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    CREATE PROC usp_delete_person(
                            @person_id INT
                        ) AS
                        BEGIN
                            BEGIN TRY
                                BEGIN TRANSACTION;
                                -- delete the person
                                DELETE FROM sales.persons
                                WHERE person_id = @person_id;
                                -- if DELETE succeeds, commit the transaction
                                COMMIT TRANSACTION;
                            END TRY
                            BEGIN CATCH
                                -- report exception
                                EXEC usp_report_error;

                                -- Test if the transaction is uncommittable.
                                IF (XACT_STATE()) = -1
                                    BEGIN
                                        PRINT  N'The transaction is in an uncommittable state.' +
                                                'Rolling back transaction.'
                                        ROLLBACK TRANSACTION;
                                    END;

                                -- Test if the transaction is committable.
                                IF (XACT_STATE()) = 1
                                    BEGIN
                                        PRINT N'The transaction is committable.' +
                                            'Committing transaction.'
                                        COMMIT TRANSACTION;
                                    END;
                            END CATCH
                        END;
                        GO
                </textarea>
            </ul>
        <h3 style="color:red">2)RAISERROR </h3>
            <ul>
                <li style="color:red"><b>If you develop a new application, you should use the THROW statement instead.</b></li>
                <li>The RAISERROR statement allows you to generate your own error messages and return these messages back to the<br>
                    application using the same format as a system error or warning message generated by SQL Server Database Engine. </li>
                <li>In addition, the RAISERROR statement allows you to set a specific message id, level of severity, and state for the error messages.</li>
                <textarea rows= "5" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    RAISERROR ( { message_id | message_text | @local_variable }
                                { ,severity ,state }
                                [ ,argument [ ,...n ] ] )
                                [ WITH option [ ,...n ] ];
                </textarea>
                <ul>
                    <li style="color:blue"><b>message_id</b></li>
                        <ul style="list-style-type:disc">
                            <li>The message_id is a user-defined error message number stored in the sys.messages catalog view.</li>
                            <li>To add a new user-defined error message number, you use the stored procedure sp_addmessage.<br>
                                A user-defined error message number should be greater than 50,000. By default, the RAISERROR statement<br>
                                uses the message_id 50,000 for raising an error.</li>
                            <li>The following statement adds a custom error message to the sys.messages view:</li>
                            <textarea rows= "5" cols="100" style="color:#1F0221; font-family:Times New Roman">
                                EXEC sp_addmessage
                                    @msgnum = 50005,
                                    @severity = 1,
                                    @msgtext = 'A custom error message';
                            </textarea>
                            <li>To verify the insert, you use the following query:</li>
                            <textarea rows= "7" cols="100" style="color:#1F0221; font-family:Times New Roman">
                                SELECT
                                    *
                                FROM
                                    sys.messages
                                WHERE
                                    message_id = 50005;
                            </textarea>
                            <li>To use this message_id, you execute the RAISEERROR statement as follows:</li>
                            <textarea rows= "2" cols="100" style="color:#1F0221; font-family:Times New Roman">
                                RAISERROR ( 50005,1,1)
                            </textarea>
                            <li>To remove a message from the sys.messages, you use the stored procedure sp_dropmessage.</li>
                            <textarea rows= "3" cols="100" style="color:#1F0221; font-family:Times New Roman">
                                EXEC sp_dropmessage
                                    @msgnum = 50005;
                            </textarea>
                        </ul>
                    <li style="color:blue"><b>message_text</b></li>
                        <ul style="list-style-type:disc">
                            <li>The message_text is a user-defined message with formatting like the printf function in C standard library.</li>
                            <li>The message_text can be up to 2,047 characters, 3 last characters are reserved for ellipsis (…). <br>
                                It means if the message_text contains 2048 or more, it will be truncated and is padded with an ellipsis.</li>
                            <li>When you specify the message_text, the RAISERROR statement uses message_id 50000 to raise the error message.</li>
                            <textarea rows= "2" cols="100" style="color:#1F0221; font-family:Times New Roman">
                                RAISERROR ( 'Whoops, an error occurred.',1,1)
                            </textarea>
                            <li>The output will look like this:</li>
                            <textarea rows= "3" cols="100" style="color:#1F0221; font-family:Times New Roman">
                                Whoops, an error occurred.
                                Msg 50000, Level 1, State 1
                            </textarea>
                        </ul>
                    <li style="color:blue"><b>severity</b></li>
                        <ul style="list-style-type:disc">
                            <li>The severity level is an integer between 0 and 25, with each level representing the seriousness of the error.</li>
                            <ul>
                                <li>0–10 Informational messages</li>
                                <li>11–18 Errors</li>
                                <li>19–25 Fatal errors</li>
                            </ul>
                        </ul>
                    <li style="color:blue"><b>state</b></li>
                        <ul style="list-style-type:disc">
                            <li>The state is an integer from 0 through 255.</li>
                            <li>If you raise the same user-defined error at multiple locations, you can use a unique state number for each location <br>
                            to make it easier to find which section of the code is causing the errors. For most implementations, you can use 1.</li>
                        </ul>
                    <li style="color:blue"><b>WITH option</b></li>
                        <ul>
                            <li><b>WITH LOG</b> : logs the error in the error log and application log for the instance of the SQL Server Database Engine.</li>
                            <li><b>WITH NOWAIT</b> : sends the error message to the client immediately.</li>
                            <li><b>WITH SETERROR</b> : sets the ERROR_NUMBER and @@ERROR values to message_id or 50000, regardless of the severity level.</li>
                        </ul>
                </ul>
                <h4 style="color:blue"><b>*Using SQL Server RAISERROR with TRY CATCH block</b></h4>
                <ul>
                    <textarea rows= "18" cols="100" style="color:#1F0221; font-family:Times New Roman">
                        DECLARE
                            @ErrorMessage  NVARCHAR(4000),
                            @ErrorSeverity INT,
                            @ErrorState    INT;

                        BEGIN TRY
                            RAISERROR('Error occurred in the TRY block.', 17, 1);
                        END TRY
                        BEGIN CATCH
                            SELECT
                                @ErrorMessage = ERROR_MESSAGE(),
                                @ErrorSeverity = ERROR_SEVERITY(),
                                @ErrorState = ERROR_STATE();

                            -- return the error inside the CATCH block
                            RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
                        END CATCH;
                    </textarea>
                    <li>we use the RAISERROR inside a TRY block to cause execution to jump to the associated CATCH block. Inside the CATCH block,<br>
                        we use the RAISERROR to return the error information that invoked the CATCH block.</li>
                </ul>
                <h4 style="color:blue"><b>*Using SQL Server RAISERROR statement with a dynamic message text</b></h4>
                <ul>
                    <textarea rows= "8" cols="100" style="color:#1F0221; font-family:Times New Roman">
                        RAISERROR (N'This is message %s %d.', -- Message text.
                                   10, -- Severity,
                                   1, -- State,
                                   N'number', -- First argument.
                                   5); -- Second argument.
                        -- The message text returned is: This is message number 5.
                        GO
                    </textarea>
                    <li style="color:red">Typically, successive arguments replace successive conversion specifications; the first argument replaces the first conversion specification,<br>
                        the second argument replaces the second conversion specification, and so on. In the above example, the first argument<br>
                        of N'number' replaces the first conversion specification of %s; and the second argument of 5 replaces the second conversion specification of %d.</li>
                </ul>
                <h4 style="color:blue"><b>*When to use RAISERROR statement</b></h4>
                <ul>
                    <li>Troubleshoot Transact-SQL code.</li>
                    <li>Return messages that contain variable text.</li>
                    <li>Examine the values of data.</li>
                    <li>Cause the execution to jump from a TRY block to the associated CATCH block.</li>
                    <li>Return error information from the CATCH block to the callers, either calling batch or application.</li>
                </ul>
            </ul>
        <h3 style="color:red">3)THROW</h3>
            <ul>
                <li>The THROW statement raises an exception and transfers execution to a CATCH block of a TRY CATCH construct.</li>
                <textarea rows= "4" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    THROW [ error_number ,
                            message ,
                            state ];
                </textarea>
                <ul>
                    <li><b>error_number</b> : The error_number is an integer that represents the exception. The error_number must be greater than 50,000 and less than or equal to 2,147,483,647.</li>
                    <li><b>message</b> : The message is a string of type NVARCHAR(2048) that describes the exception.</li>
                    <li><b>state</b> : The state is a TINYINT with the value between 0 and 255. The state indicates the state associated with the message.</li>
                </ul>
                <li style="color:blue">If you don’t specify any parameter for the THROW statement, you must place the THROW statement inside a CATCH block.<br>
                In this case, the THROW statement raises the error that was caught by the CATCH block.</li>
                <li style="color:red">Note that the statement before the THROW statement must be terminated by a semicolon (;)</li>
                <h4 style="color:blue"><b>*THROW vs. RAISERROR</b></h4>
                <img src="{% static 'IMG\Screenshot 2021-09-04 045314.png'%}">
                <h4 style="color:blue"><b>*THROW Example</b></h4>
                <textarea rows= "5" cols="100" style="color:#1F0221; font-family:Times New Roman">
                        THROW 50005, N'An error occurred', 1;
                    Output:
                        Msg 50005, Level 16, State 1, Line 1
                        An error occurred
                </textarea><br>
                <textarea rows= "10" cols="50" style="color:#1F0221; font-family:Times New Roman">
                    BEGIN TRY
                        INSERT INTO t1(id) VALUES(1);
                        --  cause error
                        INSERT INTO t1(id) VALUES(1);
                    END TRY
                    BEGIN CATCH
                        PRINT('Raise the caught error again');
                        THROW;
                    END CATCH
                </textarea>
                <textarea rows= "10" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    Output :
                        (1 row affected)

                        (0 rows affected)
                        Raise the caught error again
                        Msg 2627, Level 14, State 1, Line 10
                        Violation of PRIMARY KEY constraint 'PK__t1__3213E83F906A55AA'.
                        Cannot insert duplicate key in object 'dbo.t1'. The duplicate key value is (1).
                </textarea>
                <li>The following statement adds a custom message to the sys.messages catalog view:</li>
                <textarea rows= "8" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    EXEC sys.sp_addmessage
                        @msgnum = 50010,
                        @severity = 16,
                        @msgtext =
                        N'The order number %s cannot be deleted because it does not exist.',
                        @lang = 'us_english';
                    GO
                </textarea>
                <li>This statement uses the message_id 50010 and replaces the %s placeholder by an order id ‘1001’:</li>
                <textarea rows= "8" cols="100" style="color:#1F0221; font-family:Times New Roman">
                        DECLARE @MessageText NVARCHAR(2048);
                            SET @MessageText =  FORMATMESSAGE(50010, N'1001');

                            THROW 50010, @MessageText, 1;
                    Output:
                        Msg 50010, Level 16, State 1, Line 8
                        The order number 1001 cannot be deleted because it does not exist.
                </textarea>
            </ul>
    </ul>
<h1 style="color:#3A578F">Section 5. Dynamic SQL</h1>
    <ul>
        <li>Dynamic SQL is a programming technique that allows you to construct SQL statements dynamically at runtime.</li>
        <li>It allows you to create more general purpose and flexible SQL statement because the full text of the SQL statements may be unknown at compilation.<br>
        For example, you can use the dynamic SQL to create a stored procedure that queries data against a table whose name is not known until runtime.<br></li>
        <li style="colo:red">To execute a dynamic SQL statement, you call the stored procedure sp_executesql</li>
            <textarea rows= "2" cols="100" style="color:#1F0221; font-family:Times New Roman">
                EXEC sp_executesql N'SELECT * FROM production.products';
            </textarea>
        <li style="color:blue"><b>Because the sp_executesql accepts the dynamic SQL as a Unicode string, you need to prefix it with an N.</b></li>
        <h4 style="color:blue"><b>*Using dynamic SQL to query from any table</b></h4>
                <textarea rows= "10" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    DECLARE
                        @table NVARCHAR(128),
                        @sql NVARCHAR(MAX);

                    SET @table = N'production.products';

                    SET @sql = N'SELECT * FROM ' + @table;

                    EXEC sp_executesql @sql;
                </textarea>
        <h4 style="color:blue"><b>*SQL Server dynamic SQL and stored procedures</b></h4>
            <ul>
                <li> One variable</li>
                    <textarea rows= "14" cols="100" style="color:#1F0221; font-family:Times New Roman">
                        CREATE PROC usp_query (
                                @table NVARCHAR(128) )
                            AS
                            BEGIN

                                DECLARE @sql NVARCHAR(MAX);
                                -- construct SQL
                                SET @sql = N'SELECT * FROM ' + @table;
                                -- execute the SQL
                                EXEC sp_executesql @sql;

                            END;
                        EXEC usp_query 'production.brands';
                    </textarea>
                <li> Many variable</li>
                    <textarea rows= "26" cols="100" style="color:#1F0221; font-family:Times New Roman">
                        CREATE OR ALTER PROC usp_query_topn(
                                @table NVARCHAR(128),
                                @topN INT,
                                @byColumn NVARCHAR(128)
                                )
                            AS
                                BEGIN
                                    DECLARE
                                        @sql NVARCHAR(MAX),
                                        @topNStr NVARCHAR(MAX);

                                    SET @topNStr  = CAST(@topN as nvarchar(max));

                                    -- construct SQL
                                    SET @sql = N'SELECT TOP ' +  @topNStr  +
                                                ' * FROM ' + @table +
                                                    ' ORDER BY ' + @byColumn + ' DESC';
                                    -- execute the SQL
                                    EXEC sp_executesql @sql;

                                END;
                        EXEC usp_query_topn
                            'production.products',
                            10,
                            'list_price';
                    </textarea>
            </ul>
        <h4 style="color:blue"><b>*SQL Server Dynamic SQL and SQL Injection</b></h4>
            <ul>
                <textarea rows= "2" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    EXEC usp_query 'production.brands;DROP TABLE sales.tests';
                </textarea>
                <li>This statement returns all rows from the production.brands table and delete table sales.tests</li>
                <li>To prevent this SQL injection, the technique is called SQL injection. You can use the QUOTENAME() function</li>
                    <ul>
                        <li><b>QUOTENAME()</b> : Returns a Unicode string with the delimiters added to make the input string a valid SQL Server delimited identifier.</li>
                    </ul>
                <textarea rows= "17" cols="100" style="color:#1F0221; font-family:Times New Roman">
                    CREATE OR ALTER PROC usp_query (
                            @schema NVARCHAR(128),
                            @table  NVARCHAR(128)
                            )
                        AS
                            BEGIN
                                DECLARE
                                    @sql NVARCHAR(MAX);
                                -- construct SQL
                                SET @sql = N'SELECT * FROM '
                                    + QUOTENAME(@schema)
                                    + '.'
                                    + QUOTENAME(@table);
                                -- execute the SQL
                                EXEC sp_executesql @sql;
                            END;
                </textarea>
                <li>Now, if you try to inject another statement such as:</li>
                    <textarea rows= "4" cols="50" style="color:#1F0221; font-family:Times New Roman">
                        EXEC usp_query
                            'production',
                            'brands;DROP TABLE sales.tests';
                    </textarea>
                <li>It will issue the following error:</li>
                    <textarea rows= "2" cols="100" style="color:#1F0221; font-family:Times New Roman">
                        Invalid object name 'production.brands;DROP TABLE sales.tests'.
                    </textarea>
            </ul>
        <h4 style="color:blue"><b>*More on sp_executesql stored procedure</b></h4>
            <textarea rows= "7" cols="50" style="color:#1F0221; font-family:Times New Roman">
                EXEC sp_executesql
                    sql_statement
                    parameter_definition
                    @param1 = value1,
                    @param2 = value2,
                    ...
            </textarea>
            <ul>
                <li><b>sql_statement</b> : is a Unicode string that contains a T-SQL statement. The sql_statement can contain parameters such as SELECT * FROM table_name WHERE id=@id</li>
                <li><b>parameter_definition</b> :  is a string that contains the definition of all parameters embedded in the sql_statement. Each parameter definition consists of a<br>
                    parameter name and its data type e.g., @id INT. The parameter definitions are separated by a comma (,).</li>
                <li><b>@param1 = value1, @param2 = value2</b> : specify a value for every parameter defined in the parameter_definition string.</li>
            </ul>
            <textarea rows= "14" cols="50" style="color:#1F0221; font-family:Times New Roman">
                EXEC sp_executesql
                    N'SELECT *
                        FROM
                            production.products
                        WHERE
                            list_price> @listPrice AND
                            category_id = @categoryId
                        ORDER BY
                            list_price DESC',
                    N'@listPrice DECIMAL(10,2),
                    @categoryId INT'
                    ,@listPrice = 100
                    ,@categoryId = 1;
            </textarea>
    </ul>



















</body>
</html>